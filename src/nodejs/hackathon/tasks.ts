/**
 * Code written for:
 * 
 * 
 *                              ████
 *                              ████
 *                              ████
 *                              ████
 *                              ████
 *             ███████  ████    ████         ████████              ████████
 *           ███████████████    ████      ██████████████        ██████████████
 *         ████        █████    ████     ████        ████      ████        ████
 *        ████          ████    ████    ████          ████    ████          ████
 *         ████        █████    ████     ████        ████      ████        ████
 *          ████████████████    ████      ██████████████        ██████████████
 *             ███████  ████    ████         ████████              ████████
 *                      ████ 
 *                    █████ 
 *                 ██████    
 * 
 *                                                     AI & the Church Hackathon
 * 
 * 
 * @license The judging committee of the 2023 AI & the Church Hackathon, organized by Gloo LLC,
 * has the permission to use, review, assess, test, and otherwise analyze this file in connection 
 * with said Hackathon.
 * 
 * This file includes all the tasks that are called through API communications.
 * These tasks are calling dao functions and other task related functions.
 */

'use strict'

import * as dao from "./dao.js";
import * as prayerPromptFunctions from "../prayer_prompt/functions.js";
import OpenAI from "openai";
import { ApiError, ApiResponse, Note } from "../../api/api_response.js";
import { TaskRequirements } from "../../api/task_requirements.js";
import { canWritePrayerListItem } from "../auth.js";
import { doesJournalNoteBelongToPerson } from "../prayer_journal/dao.js";

/**
 * Getting the API key for OpenAI from an environment variable.
 */
export const OPENAI = new OpenAI({
  apiKey: process.env.OPEN_AI_API_KEY,
});


/**
 * Returns an already generated sermon if there is one, or returns a DATA_NOT_FOUND note.
 * @param z
 * @returns
 */
export async function getSermonSummary(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const sermon = await dao.getSermonNote(z.thisPerson!.role!.id);
  if (!sermon) {
    return new ApiResponse({ success: false, note: Note.DATA_NOT_FOUND });
  } else {
    return new ApiResponse({ success: true, payload: { sermon: JSON.parse(sermon) } });
  }
}

/**
 * Returns an already generated prayer prompt if there is one, otherwise returns a generic
 * one that was not generated by the AI.
 * @param z
 * @returns
 */
export async function getPrayerPrompt(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const personalPrayerPrompt = await dao.getPersonalPrayerPrompt(z.thisPerson!.role!.id);
  if (personalPrayerPrompt !== null) {
    return new ApiResponse({ success: true, payload: { prayerPrompt: personalPrayerPrompt } });
  }
  const defaultPrayerPrompt = await prayerPromptFunctions.getPrayerPrompt();
  return new ApiResponse({
    success: true,
    payload: {
      prayerPrompt: defaultPrayerPrompt.t + " " + defaultPrayerPrompt.s
    },
  });
}

/**
 * Adds a new entry to the prayer journal for a given prayer list item.
 * @param z
 * @returns
 */
export async function addHouseholdJournalEntry(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { prayerListItemId: number, newEntry: string };
  if (!Number.isInteger(payload.prayerListItemId)
    || typeof payload.newEntry !== 'string'
    || payload.newEntry.trim().length < 2
    || payload.newEntry.trim().length > 8096) {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD }); // short circuit
  }
  if (!await canWritePrayerListItem(z.thisPerson!, payload.prayerListItemId)) {
    // short circuit
    return new ApiResponse({ success: false, note: Note.NOT_ALLOWED_OR_NOT_FOUND }); 
  }
  const insertId = await dao.addHouseholdJournalEntry(payload.prayerListItemId, payload.newEntry);
  return new ApiResponse({ success: true, payload: { id: insertId } });
}

/**
 * Modifies an existing prayer journal entry.
 * @param z
 * @returns
 * Since there is no result to be returned, it is not necessary to wait for dao operations and 
 * ApiResponse(true) can be returned instantly after checking that the person can access it.
 */
export async function editHouseholdJournalEntry(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { id: number, newEntry: string };
  if (!Number.isInteger(payload.id) || typeof payload.newEntry !== 'string') {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD }); // short circuit
  }
  if (!await doesJournalNoteBelongToPerson(z.thisPerson!, payload.id)) {
    // short circuit
    return new ApiResponse({ success: false, note: Note.NOT_ALLOWED_OR_NOT_FOUND }); 
  }
  dao.editHouseholdJournalEntry(payload.id, payload.newEntry);
  return new ApiResponse({ success: true });
}

/**
 * Updates a journal note's answered flag.
 * @param z
 * @returns
 */
export async function setIfHouseholdJournalEntryIsAnswered(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { id: number, answeredState: boolean };
  if (typeof payload.answeredState !== 'boolean'
    || !Number.isInteger(payload.id)) {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD });
  }
  const result = await dao.setIfHouseholdJournalEntryIsAnswered(
    payload.id,
    payload.answeredState,
    z.thisPerson!.role!.id
  );
  if (!result) {
    return new ApiResponse({ success: false, note: Note.NOT_ALLOWED_OR_NOT_FOUND });
  }
  return new ApiResponse({ success: true });
}

/**
 * Sets a journal note's deleted flag to 1.
 * @param z
 * @returns
 */
export async function deleteHouseholdJournalEntry(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { id: number };
  if (!Number.isInteger(payload.id)) {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD });
  }
  const result = await dao.deleteHouseholdJournalEntry(payload.id, z.thisPerson!.role!.id);
  if (!result) {
    return new ApiResponse({ success: false, note: Note.NOT_ALLOWED_OR_NOT_FOUND });
  }
  return new ApiResponse({ success: true });
}

/**
 * Returns the prayer journal entries for a household.
 * @param z
 * @returns
 */
export async function getHouseholdJournalEntries(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { prayerListItemId: number };
  if (!Number.isInteger(payload.prayerListItemId)) {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD }); // short circuit
  }
  if (!await canWritePrayerListItem(z.thisPerson!, payload.prayerListItemId)) {
    // short circuit
    return new ApiResponse({ success: false, note: Note.NOT_ALLOWED_OR_NOT_FOUND }); 
  }
  const entries = await dao.getHouseholdJournalEntries(payload.prayerListItemId);
  return new ApiResponse({ success: true, payload: entries });
}

/**
 * Adds a light prayer request and returns its insert id.
 * @param z
 * @returns
 */
export async function addLightPrayerRequest(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { prayerRequest: string };
  if (typeof payload.prayerRequest !== 'string'
    || payload.prayerRequest.trim().length < 2
    || payload.prayerRequest.trim().length > 8096) {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD }); // short circuit
  }
  const insertId = await dao.addLightPrayerRequest(z.thisPerson!.role!.id, payload.prayerRequest);
  return new ApiResponse({ success: true, payload: { id: insertId } });
}

/**
 * Modifies an existing light prayer request.
 * @param z
 * @returns
 * Since there is no result to be returned, it is not necessary to wait for dao operations and 
 * ApiResponse(true) can be returned instantly after checking that the person can access it.
 */
export async function editLightPrayerRequest(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { id: number, newPrayerRequest: string };
  if (!Number.isInteger(payload.id)
    || typeof payload.newPrayerRequest !== 'string'
    || payload.newPrayerRequest.trim().length < 2
    || payload.newPrayerRequest.trim().length > 8096) {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD }); // short circuit
  }
  if (!await dao.doesLightPrayerRequestBelongToLight(payload.id, z.thisPerson!.role!.id)) {
    // short circuit
    return new ApiResponse({ success: false, note: Note.NOT_ALLOWED_OR_NOT_FOUND }); 
  }
  dao.editLightPrayerRequest(payload.id, payload.newPrayerRequest);
  return new ApiResponse({ success: true });
}

/**
 * Updates a light prayer request's answered flag.
 * @param z
 * @returns
 */
export async function setIfLightPrayerRequestIsAnswered(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { id: number, answeredState: boolean };
  if (typeof payload.answeredState !== 'boolean'
    || !Number.isInteger(payload.id)) {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD });
  }
  const result = await dao.setIfLightPrayerRequestIsAnswered(
    payload.answeredState,
    payload.id,
    z.thisPerson!.role!.id);
  if (!result) {
    return new ApiResponse({ success: false, note: Note.NOT_ALLOWED_OR_NOT_FOUND });
  }
  return new ApiResponse({ success: true });
}

/**
 * Sets a light prayer request's deleted flag to 1.
 * @param z
 * @returns
 */
export async function deleteLightPrayerRequest(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { id: number };
  if (!Number.isInteger(payload.id)) {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD });
  }
  const result = await dao.deleteLightPrayerRequest(payload.id, z.thisPerson!.role!.id);
  if (!result) {
    return new ApiResponse({ success: false, note: Note.NOT_ALLOWED_OR_NOT_FOUND });
  }
  return new ApiResponse({ success: true });
}

/**
 * Adds a church prayer request and returns its insert id.
 * @param z
 * @returns
 */
export async function addChurchPrayerRequest(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { prayerRequest: string };
  if (typeof payload.prayerRequest !== 'string'
    || payload.prayerRequest.trim().length < 2
    || payload.prayerRequest.trim().length > 8096) {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD }); // short circuit
  }
  const insertId = await dao.addChurchPrayerRequest(z.thisPerson!.role!.id, payload.prayerRequest);
  return new ApiResponse({ success: true, payload: { id: insertId } });
}

/**
 * Modifies an existing prayer request of a church.
 * @param z
 * @returns
 * Since there is no result to be returned, it is not necessary to wait for dao operations and 
 * ApiResponse(true) can be returned instantly after checking that the person can access it.
 */
export async function editChurchPrayerRequest(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { id: number, newPrayerRequest: string };
  if (!Number.isInteger(payload.id) || typeof payload.newPrayerRequest !== 'string') {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD }); // short circuit
  }
  if (!await dao.doesPrayerRequestBelongsToTheChurch(payload.id, z.thisPerson!.role!.id)) {
    // short circuit
    return new ApiResponse({ success: false, note: Note.NOT_ALLOWED_OR_NOT_FOUND }); 
  }
  dao.editChurchPrayerRequest(payload.id, payload.newPrayerRequest);
  return new ApiResponse({ success: true });
}

/**
 * Updates an church's prayer request answered flag.
 * @param z
 * @returns
 */
export async function setIfChurchPrayerRequestIsAnswered(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { id: number, answeredState: boolean };
  if (typeof payload.answeredState !== 'boolean'
    || !Number.isInteger(payload.id)) {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD });
  }
  const result = await dao.setIfChurchPrayerRequestIsAnswered(
    payload.answeredState,
    payload.id,
    z.thisPerson!.role!.id);
  if (!result) {
    return new ApiResponse({ success: false, note: Note.NOT_ALLOWED_OR_NOT_FOUND });
  }
  return new ApiResponse({ success: true });
}

/**
 * Sets an church's prayer request deleted flag to 1.
 * @param z
 * @returns
 */
export async function deleteChurchPrayerRequest(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const payload = z.apiRequest.payload as { id: number };
  if (!Number.isInteger(payload.id)) {
    return new ApiResponse({ success: false, error: ApiError.BAD_PAYLOAD });
  }
  const result = await dao.deleteChurchPrayerRequest(payload.id, z.thisPerson!.role!.id);
  if (!result) {
    return new ApiResponse({ success: false, note: Note.NOT_ALLOWED_OR_NOT_FOUND });
  }
  return new ApiResponse({ success: true });
}

/** 
 * Returns the prayer requests of a church.
 * @param z
 * @returns
 */
export async function getChurchPrayerRequests(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const result = await dao.getChurchPrayerRequests(z.thisPerson!.role!.id);
  return new ApiResponse({ success: true, payload: result });
}

/**
 * Returns a recommended youversion plan for a light.
 * @param z
 * @returns
 */
export async function getYouVersionPlan(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const plan = await dao.getYouVersionPlan(z.thisPerson!.role!.id);
  if (plan) {
    return new ApiResponse({ success: true, payload: plan });
  } else {
    return new ApiResponse({ success: false, note: Note.DATA_NOT_FOUND });
  }
}

/**
 * Returns a light's prayer requests.
 * @param z
 * @returns
 */
export async function getLightPrayerRequests(
  z: TaskRequirements,
): Promise<ApiResponse> {
  const prayerRequests = await dao.getLightPrayerRequests(z.thisPerson!.role!.id);
  return new ApiResponse({ success: true, payload: prayerRequests });
}